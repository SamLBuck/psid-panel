out <- load_wave(y, fam_vars, "FAMILY")
if (!is.null(out)) attr(out, "map_row") <- row
out
})
fam <- rbindlist(fam_list, fill = TRUE)
if (!nrow(fam)) stop("Loaded 0 rows for FAMILY; verify psid_dir and your CSV ER codes.")
setwd('C:/Users/frost01/Documents/PSIDdata')
#install.packages("readxl")
library(readxl)
#install.packages('psidR')
library(psidR)
#install.packages('devtools')
library(devtools)
#install.packages("data.table")
library(data.table)
psid_dir <- "C:/Users/frost01/Documents/PSIDdata"       # <-- change if needed
stopifnot(dir.exists(psid_dir))
# 2) load your CSV of ER codes (the one you filled)
map_csv <- "C:/Users/frost01/Documents/Fill_this_with_ER_variable_numbers_by_wave__save_and_reupload_if_you_edit_locally__.csv"
stopifnot(file.exists(map_csv))
map_csv <- "C:/Users/frost01/Documents/Fill_this_with_ER_variable_numbers_by_wave__save_and_reupload_if_you_edit_locally__.csv"
map_csv <- "C:/Users/frost01/Documents/PSIDdata/Fill_this_with_ER_variable_numbers_by_wave__save_and_reupload_if_you_edit_locally__.csv"
stopifnot(file.exists(map_csv))
map <- fread(map_csv)
psid_dir <- "C:/Users/frost01/Documents/PSIDdata"       # <-- change if needed
stopifnot(dir.exists(psid_dir))
# 2) load your CSV of ER codes (the one you filled)
map_csv <- "C:/Users/frost01/Documents/PSIDdata/Fill_this_with_ER_variable_numbers_by_wave__save_and_reupload_if_you_edit_locally__.csv"
stopifnot(file.exists(map_csv))
map <- fread(map_csv)
map <- map[year %% 2 == 1]
norm_na <- function(x) { x[is.na(x)] <- ""; x }
View(fam_list)
View(ind)
View(ind_list)
View(ind_vars)
map_csv <- "C:/Users/frost01/Documents/PSIDdata/Fill_this_with_ER_variable_numbers_by_wave__save_and_reupload_if_you_edit_locally__.csv"
stopifnot(file.exists(map_csv))
map <- fread(map_csv)
map <- map[year %% 2 == 1]
# 3) construct fam.vars and ind.vars in the format build.panel() expects:
# one row per year
#each column is a variable “name” you want in the output
# each cell is the *ER variable name for that wave
norm_na <- function(x) { x[is.na(x)] <- ""; x }
fam_vars <- data.frame(
year      = map$year,
interview = norm_na(map$ER_interview_num),        # REQUIRED to join across files reliably
faminc    = norm_na(map$ER_total_family_income),  # example: total family income
release   = norm_na(map$ER_release_num),          # optional
hh_id     = norm_na(map$ER_household_ID),         # optional
seqnum    = norm_na(map$ER_sequence_num),         # optional
stringsAsFactors = FALSE
)
View(fam_vars)
fam_vars <- fam_vars[, colSums(fam_vars != "") > 0, drop = FALSE]
# IND file selections
ind_vars <- data.frame(
year        = map$year,
rel_to_head = norm_na(map$ER_relation_to_head),   # relation code
age         = norm_na(map$ER_age),                # age
stringsAsFactors = FALSE
)
View(ind_list)
ind_vars <- ind_vars[, colSums(ind_vars != "") > 0, drop = FALSE]
View(ind_vars)
if (!("year" %in% names(fam_vars)) || ncol(fam_vars) < 2) {
stop("fam.vars has no usable variables (only 'year'). Fill ER codes in your CSV for at least 'ER_interview_num' and one data field.")
}
fam_year <- psidR::build.panel(
datadir     = psid_dir,
fam.vars    = fam_vars,
ind.vars    = NULL,          # family-year only
heads.only  = TRUE,
design      = "all"          # keep all observed heads across years
)
yes
ind_vars <- ind_vars[, colSums(ind_vars != "") > 0, drop = FALSE]
if (!("year" %in% names(fam_vars)) || ncol(fam_vars) < 2) {
stop("fam.vars has no usable variables (only 'year'). Fill ER codes in your CSV for at least 'ER_interview_num' and one data field.")
}
fam_year <- psidR::build.panel(
datadir     = psid_dir,
fam.vars    = fam_vars,
ind.vars    = NULL,          # family-year only
heads.only  = TRUE,
design      = "all"          # keep all observed heads across years
)
psid_dir <- "C:/Users/frost01/Documents/PSIDdata"
dir.create(psid_dir, showWarnings = FALSE, recursive = TRUE)
# some psidR builds honor this to skip the prompt
options(psidR.auto.download = TRUE)
# try again; include download flag if your version supports it
fam_year <- psidR::build.panel(
datadir    = psid_dir,
fam.vars   = fam_vars,
ind.vars   = NULL,
heads.only = TRUE,
design     = "all",
download   = TRUE   # if your psidR has this arg
)
psid_dir <- "C:/Users/frost01/Documents/PSIDdata"
dir.create(psid_dir, showWarnings = FALSE, recursive = TRUE)
# some psidR builds honor this to skip the prompt
options(psidR.auto.download = TRUE)
# try again; include download flag if your version supports it
fam_year <- psidR::build.panel(
datadir    = psid_dir,
fam.vars   = fam_vars,
ind.vars   = NULL,
heads.only = TRUE,
design     = "all",
download   = TRUE   # if your psidR has this arg
fam_vars <- data.frame(
fam_vars <- data.frame(
year      = map$year,
interview = norm_na(map$ER_interview_num),        # REQUIRED to join across files reliably
faminc    = norm_na(map$ER_total_family_income),  # example: total family income
release   = norm_na(map$ER_release_num),          # optional
hh_id     = norm_na(map$ER_household_ID),         # optional
seqnum    = norm_na(map$ER_sequence_num),         # optional
stringsAsFactors = FALSE
)
fam_vars <- fam_vars[, colSums(fam_vars != "") > 0, drop = FALSE]
# IND file selections
ind_vars <- data.frame(
year        = map$year,
rel_to_head = norm_na(map$ER_relation_to_head),   # relation code
age         = norm_na(map$ER_age),                # age
stringsAsFactors = FALSE
)
ind_vars <- ind_vars[, colSums(ind_vars != "") > 0, drop = FALSE]
if (!("year" %in% names(fam_vars)) || ncol(fam_vars) < 2) {
stop("fam.vars has no usable variables (only 'year'). Fill ER codes in your CSV for at least 'ER_interview_num' and one data field.")
}
fam_year <- psidR::build.panel(
datadir     = psid_dir,
fam.vars    = fam_vars,
ind.vars    = NULL,          # family-year only
heads.only  = TRUE,
design      = "all"          # keep all observed heads across years
)
intall.packages"psidR"
intall.packages("psidR")
install.packages("psidR")
years_needed <- unique(fam_vars$year)
fam_year <- psidR::build.panel(
datadir    = psid_dir,
fam.vars   = fam_vars,
ind.vars   = NULL,
heads.only = TRUE,
design     = "all"
)
install.packages("psidR")
setwd('C:/Users/frost01/Documents/PSIDdata')
#install.packages("readxl")
library(readxl)
#install.packages('psidR')
library(psidR)
#install.packages('devtools')
library(devtools)
#install.packages("data.table")
library(data.table)
years_needed <- unique(fam_vars$year)
fam_year <- psidR::build.panel(
datadir    = psid_dir,
fam.vars   = fam_vars,
ind.vars   = NULL,
heads.only = TRUE,
design     = "all"
)
library(psidR)
years_needed <- unique(fam_vars$year)
fam_year <- psidR::build.panel(
datadir    = psid_dir,
fam.vars   = fam_vars,
ind.vars   = NULL,
heads.only = TRUE,
design     = "all"
)
fam_year <- psidR::build.panel(
datadir    = psid_dir,
fam.vars   = fam_vars,
ind.vars   = NULL,
heads.only = TRUE,
design     = "all"
# some psidR versions also accept: download = TRUE
)
options(psidR.icpsr.user = "samuel.buck@hope.edu")
options(psidR.icpsr.pass = "123Turtles123")
options(psidR.auto.download = TRUE)
fam_year <- psidR::build.panel(
datadir    = psid_dir,
fam.vars   = fam_vars,
ind.vars   = NULL,
heads.only = TRUE,
design     = "all"
)
fam_year <- psidR::build.panel(
datadir    = psid_dir,
fam.vars   = fam_vars,
ind.vars   = NULL,
heads.only = TRUE,
design     = "all"
)
psidR::download_fam(years_needed, datadir = psid_dir)
psid_dir <- normalizePath("C:/Users/frost01/Documents/PSIDdata", winslash="/")
if (!grepl("/$", psid_dir)) psid_dir <- paste0(psid_dir, "/")
dir.create(psid_dir, showWarnings = FALSE, recursive = TRUE)
options(
psidR.icpsr.user = "samuel.buck@hope.edu",     # change
psidR.icpsr.pass = "123Turtles123",  # change (you should rotate this now)
psidR.auto.download = TRUE,
timeout = max(600, getOption("timeout"))
)
fam_year <- psidR::build.panel(
datadir    = psid_dir,
fam.vars   = fam_vars,
ind.vars   = NULL,
heads.only = TRUE,
design     = "all"
)
packageVersion("psidR")
ls("package:psidR")                # see what functions are exported in your version
list.files(psid_dir)               # do any .rda/.RData files exist yet?
list.files("C:/Users/frost01/Documents/PSIDdata", pattern="FAM2017ER")
psid_dir <- "C:/Users/frost01/Documents/PSIDdata/"
for (yr in c( 2017)) {
psidR::build.psid(year = yr, datadir = psid_dir)
}
psidR::build.psid(year = 2017, datadir = psid_dir, syntax = "do")
list.files(psid_dir, pattern = "^FAM2017ER\\.(txt|TXT)$")
list.files(psid_dir, pattern = "^FAM2017ER\\.(do|sps|DO|SPS)$")
psidR::build.psid(
year    = 2017,
datadir = psid_dir,
syntax  = "do",     # or "sps" if you have the SPSS syntax
encoding = "latin1" # often required on Windows for PSID files
(
year    = 2017,
datadir = psid_dir,
syntax  = "do",     # or "sps" if you have the SPSS syntax
encoding = "latin1" # often required on Windows for PSID files
)
psidR::build.psid(
psidR::build.psid(
year    = 2017,
datadir = psid_dir,
syntax  = "do",     # or "sps" if you have the SPSS syntax
encoding = "latin1" # often required on Windows for PSID files
)
psidR::build.psid(years = 2017, where = psid_dir)
psid_dir <- normalizePath("C:/Users/frost01/Documents/PSIDdata", winslash="/")
psidR::build.psid(years = 2017, where = psid_dir)
library(psidR)
psid_dir <- "C:/Users/frost01/Documents/PSIDdata/"
if (!grepl("/$", psid_dir)) psid_dir <- paste0(psid_dir, "/")
# 1) sanity: the raw files must be extracted here with exact stems
stopifnot(
file.exists(file.path(psid_dir, "FAM2017ER.txt")),
file.exists(file.path(psid_dir, "FAM2017ER.do")) ||
file.exists(file.path(psid_dir, "FAM2017ER.sps"))
)
# 2) build the RDA for 2017
psidR::build.psid(years = 2017, where = psid_dir)
library(psidR)
psid_dir <- "C:/Users/frost01/Documents/PSIDdata/"
if (!grepl("/$", psid_dir)) psid_dir <- paste0(psid_dir, "/")
# sanity: files must be EXTRACTED in psid_dir with these exact stems
stopifnot(
file.exists(file.path(psid_dir, "FAM2017ER.txt")),
file.exists(file.path(psid_dir, "FAM2017ER.do")) ||
file.exists(file.path(psid_dir, "FAM2017ER.sps"))
)
# CALL POSITIONALLY (no arg names)
psidR::build.psid(2017, psid_dir)
args(psidR::build.psid)
# or, to see the body:
getAnywhere(build.psid)
dat2017 <- psidR:::read.psid(2017, psid_dir, syntax = "do", encoding = "latin1")
install.packages("remotes")   # only if you don’t already have it
remotes::install_github("floswald/psidR")
library(psidR)
packageVersion("psidR")      # should now show ≥ 2.4
remotes::install_github("floswald/psidR")
packageVersion("psidR")      # should now show ≥ 2.4
remove.packages("psidR")
remotes::install_github(
"floswald/psidR",
force = TRUE,
build_vignettes = FALSE,
dependencies = TRUE
)
library(tidyverse)
library(readr)
install.packages('arrow')
library(arrow)
install.packages('glue')
library(glue)
install.packages('stringr')
library(stringr)
install.packages('fs')
library(fs)
install.packages('here')
install.packages("glue")
suppressPackageStartupMessages({
library(readr); library(dplyr); library(stringr); library(tibble)
library(purrr); library(fs);    library(glue);    library(here)
library(arrow)
})
# ---- paths ----
DATA_DIR  <- here("data_raw")
XWALK_DIR <- here("xwalk")
OUT_PATH  <- here("output", "psid_family_year_2001_latest.parquet")
dir_create(DATA_DIR); dir_create(XWALK_DIR); dir_create(path_dir(OUT_PATH))
# If you only want specific waves, set here; otherwise we’ll auto-detect
waves <- c(2001, 2003)
`%OR%` <- function(x, y) if (is.null(x) || length(x) == 0 || all(is.na(x))) y else x
parse_sps_positions <- function(dict_path) {
lines <- read_lines(dict_path)
dl_start <- which(str_detect(lines, regex("^\\s*DATA\\s+LIST", ignore_case = TRUE)))
if (!length(dl_start)) return(tibble(var=character(), start=integer(), end=integer(), width=integer(), type=character()))
after <- lines[seq(dl_start[1], length(lines))]
stop_idx <- which(str_detect(after, regex("^\\s*VARIABLE\\s+LABELS", ignore_case = TRUE)))
if (length(stop_idx)) after <- after[seq(1, stop_idx[1] - 1)]
after <- gsub("\\t", " ", after)
after <- gsub("\\*.*$", "", after)
after <- str_squish(after)
after <- after[after != ""]
sl <- which(str_detect(after, "^/"))
if (length(sl)) after <- after[seq(sl[1], length(after))]
blob <- paste(after, collapse = " ")
m <- str_match_all(blob, "(?i)\\b([A-Za-z0-9_]+)\\s+(\\d+)\\s*-\\s*(\\d+)\\s*(\\([aA]\\))?")[[1]]
if (!nrow(m)) return(tibble(var=character(), start=integer(), end=integer(), width=integer(), type=character()))
tibble(
var   = m[,2],
start = as.integer(m[,3]),
end   = as.integer(m[,4]),
type  = ifelse(!is.na(m[,5]) & m[,5] != "", "character", "numeric")
) |>
mutate(width = end - start + 1L) |>
distinct(var, .keep_all = TRUE) |>
arrange(start)
}
parse_do_positions <- function(dict_path) {
lines <- read_lines(dict_path) |> str_squish()
pat <- "(str\\d+|byte|int|long|double)?\\s*([A-Za-z0-9_]+)\\s+(\\d+)\\s*-\\s*(\\d+)"
toks <- str_extract_all(lines, pat) |> unlist()
if (!length(toks)) return(tibble(var=character(), start=integer(), end=integer(), width=integer(), type=character()))
mats <- str_match_all(toks, pat)
map_dfr(mats, ~tibble(
type_token = .x[,2],
var        = .x[,3],
start      = as.integer(.x[,4]),
end        = as.integer(.x[,5])
)) |>
mutate(width = end - start + 1L,
type  = ifelse(!is.na(type_token) & str_detect(type_token, "^str\\d+$"), "character", "numeric")) |>
select(var, start, end, width, type) |>
distinct(var, .keep_all = TRUE) |>
arrange(start)
}
get_dict_positions <- function(stem) {
sps <- path(DATA_DIR, paste0(stem, ".sps"))
dof <- path(DATA_DIR, paste0(stem, ".do"))
if (file_exists(sps)) return(parse_sps_positions(sps))
if (file_exists(dof)) return(parse_do_positions(dof))
warning(glue("No .sps or .do dictionary found for {stem}"));
tibble(var=character(), start=integer(), end=integer(), width=integer(), type=character())
}
read_fixed_width <- function(stem) {
txt <- path(DATA_DIR, paste0(stem, ".txt"))
if (!file_exists(txt)) {
warning(glue("Missing {path_file(txt)}"));
return(tibble())
}
dict <- get_dict_positions(stem)
if (!nrow(dict)) {
warning(glue("No positions parsed from dictionary for {stem}"));
return(tibble())
}
fwf <- readr::fwf_positions(dict$start, dict$end, dict$var)
col_types <- paste(ifelse(dict$type == "character", "c", "d"), collapse = "")
df <- readr::read_fwf(file = txt, col_positions = fwf, col_types = col_types, na = c("", " ", ".", "NA"))
char_cols <- names(df)[map_lgl(df, is.character)]
df |> mutate(across(all_of(char_cols), ~na_if(str_trim(.x), "")))
}
safe_read_xwalk <- function(fname) {
p <- path(XWALK_DIR, fname)
if (!file_exists(p)) return(tibble(wave=integer(), varname=character(), source=character()))
out <- tryCatch(
readr::read_csv(p, show_col_types = FALSE),
error = function(e) tibble(wave=integer(), varname=character(), source=character())
)
names(out) <- tolower(trimws(names(out)))
needed <- c("wave","varname","source")
if (!all(needed %in% names(out))) return(tibble(wave=integer(), varname=character(), source=character()))
mutate(out, wave = as.integer(wave))
}
family_xw <- safe_read_xwalk("family_vars_crosswalk.csv")
hs_xw     <- safe_read_xwalk("head_spouse_crosswalk.csv")
indocc_xw <- safe_read_xwalk("industry_occupation_xwalk.csv")
phil_xw   <- safe_read_xwalk("philanthropy_crosswalk.csv")
mob_xw    <- safe_read_xwalk("mobility_crosswalk.csv")
state_xw  <- safe_read_xwalk("state_crosswalk.csv")
roster_xw <- safe_read_xwalk("roster_crosswalk.csv")
apply_xwalk <- function(df, xw, yr) {
if (!nrow(df) || !nrow(xw)) return(tibble())
xwy <- xw |> filter(wave == yr)
if (!nrow(xwy)) return(tibble())
keep <- intersect(xwy$source, names(df))
if (!length(keep)) return(tibble())
out <- select(df, all_of(keep))
names(out) <- xwy |> filter(source %in% keep) |> arrange(match(source, keep)) |> pull(varname)
out
}
# Remove duplicate-named columns, keeping the first
dedup_cols <- function(df) {
if (anyDuplicated(names(df))) df <- df[, !duplicated(names(df)), drop = FALSE]
df
}
load_family_wave <- function(yr) read_fixed_width(glue("FAM{yr}ER")) |> mutate(wave = yr)
load_indiv_wave  <- function(yr) {
stems <- c(glue("IND{yr}ER"), glue("PR{yr}ER"))
pick  <- stems[file_exists(path(DATA_DIR, paste0(stems, ".txt")))]
if (!length(pick)) return(NULL)
read_fixed_width(pick[[1]]) |> mutate(wave = yr)
}
find_family_id_col <- function(fam_df, yr) {
src <- family_xw |> filter(wave == yr, varname == "family_id") |> pull(source) |> first()
if (!is.na(src) && src %in% names(fam_df)) return(src)
cands <- grep("^ER\\d{4,6}02$", names(fam_df), value = TRUE)
if (length(cands)) {
score <- vapply(cands, function(v){
x <- suppressWarnings(as.numeric(fam_df[[v]]))
n <- length(x); u <- length(unique(x))
ok_num <- mean(!is.na(x)); ok_pos <- mean(x > 0, na.rm = TRUE)
u / n + 0.5*ok_num + 0.25*ok_pos
}, numeric(1))
return(cands[which.max(score)])
}
if ("ER30002" %in% names(fam_df)) return("ER30002")
stop("Could not identify family ID column for wave ", yr,
". Add a row to family_vars_crosswalk.csv: wave,varname,source => ",
yr, ",family_id,ERxxxxx")
}
find_interview_year <- function(fam_df, yr) {
src <- family_xw |> filter(wave == yr, varname == "interview_year") |> pull(source) |> first()
if (!is.na(src) && src %in% names(fam_df)) return(suppressWarnings(as.integer(fam_df[[src]])))
if ("ER30000" %in% names(fam_df)) return(suppressWarnings(as.integer(fam_df[["ER30000"]])))
rep.int(as.integer(yr), nrow(fam_df))
}
build_wave <- function(yr) {
fam <- load_family_wave(yr)
if (!nrow(fam)) return(tibble())
ind <- load_indiv_wave(yr)
fam_id_col <- find_family_id_col(fam, yr)
keys <- tibble(
family_id      = fam[[fam_id_col]],
interview_year = find_interview_year(fam, yr),
wave           = as.integer(yr)
)
# prevent re-adding keys from the family crosswalk
fam_xw_no_keys <- family_xw |> filter(!(varname %in% c("family_id","interview_year","wave")))
add <- function(base, piece) if (!is.null(piece) && ncol(piece) > 0) bind_cols(base, piece) else base
out <- keys |>
add(apply_xwalk(fam, fam_xw_no_keys, yr)) |>
add(apply_xwalk(fam, hs_xw,     yr)) |>
add(apply_xwalk(fam, indocc_xw, yr)) |>
add(apply_xwalk(fam, phil_xw,   yr)) |>
add(apply_xwalk(fam, mob_xw,    yr)) |>
add(apply_xwalk(fam, state_xw,  yr))
# Optional: children < 18 (only if roster_xw + IND/PR are available)
if (!is.null(ind) && nrow(roster_xw) && any(roster_xw$wave == yr)) {
rxy <- roster_xw |> filter(wave == yr)
age  <- rxy |> filter(varname=="age") |> pull(source)  |> first()
in_fu<- rxy |> filter(varname=="in_fu") |> pull(source) |> first()
rel  <- rxy |> filter(varname=="rel_to_head") |> pull(source) |> first()
if (!any(is.na(c(age,in_fu,rel))) && all(c(age,in_fu,rel) %in% names(ind))) {
IND_FID <- if ("ER30002" %in% names(ind)) "ER30002" else fam_id_col
kids <- ind |>
transmute(family_id = .data[[IND_FID]],
age = suppressWarnings(as.numeric(.data[[age]])),
in_fu = .data[[in_fu]]) |>
mutate(in_fu_ok = if (is.numeric(in_fu)) in_fu == 1 else in_fu %in% c("1","Y","YES")) |>
filter(in_fu_ok, !is.na(age), age < 18) |>
count(family_id, name = "n_children_u18")
out <- out |> left_join(kids, by = "family_id")
}
}
if (!"n_children_u18" %in% names(out)) out <- mutate(out, n_children_u18 = 0L)
dedup_cols(out)
}
fam_txts    <- dir_ls(DATA_DIR, regexp = "(?i)FAM\\d{4}ER\\.txt$")
found_years <- str_extract(path_file(fam_txts), "\\d{4}") |> as.integer()
use_years   <- (waves %OR% found_years) |> intersect(found_years) |> sort()
if (!length(use_years)) stop("No FAM####ER.txt files found in ", DATA_DIR)
panel <- map_dfr(use_years, build_wave)
# Normalize/guarantee keys
if (!"family_id" %in% names(panel)) stop("Build returned no family_id. Check crosswalk for family_id or heuristics.")
if (!"wave" %in% names(panel))      panel <- mutate(panel, wave = as.integer(NA))
if (!"interview_year" %in% names(panel)) panel <- mutate(panel, interview_year = wave)
panel <- panel |>
mutate(interview_year = coalesce(interview_year, wave)) |>
filter(!is.na(family_id), !is.na(wave), wave >= 2001) |>
arrange(family_id, interview_year) |>
relocate(family_id, interview_year, wave)
write_parquet(panel, OUT_PATH)
message("Skeleton written: ", OUT_PATH,
"  | rows=", nrow(panel), "  cols=", ncol(panel),
"  | waves=", paste(unique(panel$wave), collapse=", "))
View(panel)
