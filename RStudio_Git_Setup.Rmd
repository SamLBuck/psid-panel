---
title: "Git_Setup"
output: html_document
date: "2025-10-20"
---

```{r setup, include=FALSE}
setwd('C:/Users/frost01/Documents/PSIDdata')
#install.packages("readxl")
library(readxl)
#install.packages('psidR')
library(psidR)
#install.packages('devtools')
    library(devtools)

#install.packages("data.table")
library(data.table)

install.packages("remotes")   # only if you don’t already have it
remotes::install_github("floswald/psidR")
remove.packages("psidR")

remotes::install_github(
  "floswald/psidR",
  force = TRUE,
  build_vignettes = FALSE,
  dependencies = TRUE
)

```

## R
```{r}
psid_dir <- "C:/Users/frost01/Documents/PSIDdata"
dir.create(psid_dir, showWarnings = FALSE, recursive = TRUE)

# some psidR builds honor this to skip the prompt
options(psidR.auto.download = TRUE)

# try again; include download flag if your version supports it
fam_year <- psidR::build.panel(
  datadir    = psid_dir,
  fam.vars   = fam_vars,
  ind.vars   = NULL,
  heads.only = TRUE,
  design     = "all",
  download   = TRUE   # if your psidR has this arg
)

install.packages("psidR")
library(psidR)
years_needed <- unique(fam_vars$year)

packageVersion("psidR")      # should now show ≥ 2.4


options(
  psidR.icpsr.user = "samuel.buck@hope.edu",   
  psidR.icpsr.pass = "123Turtles123",  # 
  psidR.auto.download = TRUE,
  timeout = max(600, getOption("timeout"))
)

packageVersion("psidR")
ls("package:psidR")               
list.files(psid_dir)    


psid_dir <- normalizePath("C:/Users/frost01/Documents/PSIDdata", winslash="/")
if (!grepl("/$", psid_dir)) psid_dir <- paste0(psid_dir, "/")
dir.create(psid_dir, showWarnings = FALSE, recursive = TRUE)

fam_year <- psidR::build.panel(
  datadir    = psid_dir,
  fam.vars   = fam_vars,
  ind.vars   = NULL,
  heads.only = TRUE,
  design     = "all"
)

list.files("C:/Users/frost01/Documents/PSIDdata", pattern="FAM2017ER")
psid_dir <- "C:/Users/frost01/Documents/PSIDdata/"
psid_dir <- "C:/Users/frost01/Documents/PSIDdata/"

list.files(psid_dir, pattern = "^FAM2017ER\\.(txt|TXT)$")
list.files(psid_dir, pattern = "^FAM2017ER\\.(do|sps|DO|SPS)$")


psidR::build.psid(years = 2017, where = psid_dir)


library(psidR)

psid_dir <- "C:/Users/frost01/Documents/PSIDdata/"
if (!grepl("/$", psid_dir)) psid_dir <- paste0(psid_dir, "/")

# sanity: files must be EXTRACTED in psid_dir with these exact stems
stopifnot(
  file.exists(file.path(psid_dir, "FAM2017ER.txt")),
  file.exists(file.path(psid_dir, "FAM2017ER.do")) || 
  file.exists(file.path(psid_dir, "FAM2017ER.sps"))
)

# CALL POSITIONALLY (no arg names)
psidR::build.psid(2017, psid_dir)

# confirm the R data was created
list.files(psid_dir, pattern = "(?i)^FAM2017ER\\.(rda|rdata)$")

args(psidR::build.psid)
# or, to see the body:
getAnywhere(build.psid)

dat2017 <- psidR:::read.psid(2017, psid_dir, syntax = "do", encoding = "latin1")
save(dat2017, file = file.path(psid_dir, "FAM2017ER.RDA"))


```

```{r cars}




psid_dir <- "C:/Users/frost01/Documents/PSIDdata"       # <-- change if needed
stopifnot(dir.exists(psid_dir))

# 2) load your CSV of ER codes (the one you filled)
map_csv <- "C:/Users/frost01/Documents/PSIDdata/Fill_this_with_ER_variable_numbers_by_wave__save_and_reupload_if_you_edit_locally__.csv"
stopifnot(file.exists(map_csv))
map <- fread(map_csv)

#only odd years
map <- map[year %% 2 == 1]

# 3) construct fam.vars and ind.vars in the format build.panel() expects:
# one row per year
#each column is a variable “name” you want in the output
# each cell is the *ER variable name for that wave
norm_na <- function(x) { x[is.na(x)] <- ""; x }

# choose which columns to pull from FAMILY and IND files
fam_vars <- data.frame(
  year      = map$year,
  interview = norm_na(map$ER_interview_num),        # REQUIRED to join across files reliably
  faminc    = norm_na(map$ER_total_family_income),  # example: total family income
  release   = norm_na(map$ER_release_num),          # optional
  hh_id     = norm_na(map$ER_household_ID),         # optional
  seqnum    = norm_na(map$ER_sequence_num),         # optional
  stringsAsFactors = FALSE
)

# drop columns that are entirely blank
fam_vars <- fam_vars[, colSums(fam_vars != "") > 0, drop = FALSE]

# IND file selections
ind_vars <- data.frame(
  year        = map$year,
  rel_to_head = norm_na(map$ER_relation_to_head),   # relation code
  age         = norm_na(map$ER_age),                # age
  stringsAsFactors = FALSE
)

ind_vars <- ind_vars[, colSums(ind_vars != "") > 0, drop = FALSE]

if (!("year" %in% names(fam_vars)) || ncol(fam_vars) < 2) {
  stop("fam.vars has no usable variables (only 'year'). Fill ER codes in your CSV for at least 'ER_interview_num' and one data field.")
}

# 4) build family–year 
fam_year <- psidR::build.panel(
  datadir     = psid_dir,
  fam.vars    = fam_vars,
  ind.vars    = NULL,          # family-year only
  heads.only  = TRUE,
  design      = "all"          # keep all observed heads across years
)

cat("fam_year dim:", paste(dim(fam_year), collapse = " x "), "\n")
print(head(fam_year))

# 5) optional: build family–individual–year (adds IND vars you specified)
fi_long <- psidR::build.panel(
  datadir     = psid_dir,
  fam.vars    = fam_vars,
  ind.vars    = if (ncol(ind_vars) > 1) ind_vars else NULL,
  heads.only  = FALSE,
  design      = "all"
)

cat("fi_long  dim:", paste(dim(fi_long), collapse = " x "), "\n")
print(head(fi_long))

# 6) write outputs
out_dir <- file.path(psid_dir, "_psidR_outputs")
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)
data.table::fwrite(as.data.table(fam_year), file.path(out_dir, "family_year_psidR.csv"))
data.table::fwrite(as.data.table(fi_long),  file.path(out_dir, "family_individual_year_psidR.csv"))
cat("Wrote:\n  - ", file.path(out_dir, "family_year_psidR.csv"),
    "\n  - ", file.path(out_dir, "family_individual_year_psidR.csv"), "\n")
# ---- paths
psid_dir <- "C:/Users/frost01/Documents/PSIDdata"   # <-- CHANGE THIS to your actual folder
# 2) Your ER crosswalk CSV (the one you filled)
map_csv  <- "C:/Users/frost01/Documents/Fill_this_with_ER_variable_numbers_by_wave__save_and_reupload_if_you_edit_locally__.csv"

# ---- sanity checks
if (!dir.exists(psid_dir)) stop("psid_dir doesn't exist: ", psid_dir)
if (!file.exists(map_csv)) stop("Crosswalk CSV not found: ", map_csv)

# ---- read mapping (must include at least: year, ER_famid1968 or ER_interview_num)
map <- fread(map_csv)
if (!"year" %in% names(map)) stop("Your CSV must have a 'year' column.")

# If you only want odd-year panel, uncomment next line:
# map <- map[year %% 2 == 1]

years <- sort(unique(map$year))

# ---- helper: fuzzy file finder (no fixed folder structure required)
find_file <- function(year, kind = c("FAMILY","IND")) {
  kind <- match.arg(kind)
  if (!dir.exists(psid_dir)) return(NA_character_)
  # Look for family vs individual files; accept both .dta and .sas7bdat
  pat_base <- if (kind == "FAMILY") "(FAM|FAMILY)" else "(IND|INDIV)"
  # prioritize year in filename
  all <- list.files(psid_dir, pattern = "\\.(dta|sas7bdat)$", full.names = TRUE,
                    ignore.case = TRUE, recursive = TRUE)
  cand <- grep(pat_base, all, ignore.case = TRUE, value = TRUE)
  # prefer those that include the 4-digit year
  cand_year <- grep(sprintf("%d", year), cand, value = TRUE)
  pick <- if (length(cand_year)) cand_year else cand
  if (!length(pick)) return(NA_character_)
  pick[1]
}

# ---- loader that selects only the ER codes provided for that year
load_wave <- function(year, er_vars, kind = c("FAMILY","IND")) {
  kind <- match.arg(kind)
  f <- find_file(year, kind)
  if (is.na(f)) {
    warning(sprintf("%s file missing for %s (search under: %s)", kind, year, psid_dir))
    return(NULL)
  }
  dt <- if (grepl("\\.dta$", f, ignore.case = TRUE)) read_dta(f) else read_sas(f)
  setDT(dt)
  # Select strictly by ER names; ignore blanks/missing from the CSV
  keep <- er_vars[er_vars != "" & !is.na(er_vars)]
  keep <- intersect(keep, names(dt))
  if (!length(keep)) {
    warning(sprintf("No requested ER variables found in %s %s (file: %s)", kind, year, basename(f)))
    return(NULL)
  }
  out <- dt[, ..keep]
  out[, year := year]
  attr(out, "source_file") <- f
  out
}

# columns expected in your CSV (names can be different, but these are assumed below)
# FAMILY-level candidates
fam_cols <- c("ER_release_num", "ER_total_family_income", "ER_household_ID",
              "ER_interview_num", "ER_sequence_num", "ER_famid1968")
need_any_fam_key <- c("ER_famid1968", "ER_interview_num")

# INDIVIDUAL-level candidates
ind_cols <- c("ER_relation_to_head", "ER_age", "ER_perid1968", "ER_famid1968", "ER_interview_num")

#build FAMILY by year
fam_list <- lapply(years, function(y) {
  row <- map[year == y]
  if (!nrow(row)) return(NULL)
  fam_vars <- unlist(row[, ..fam_cols], use.names = FALSE)
  out <- load_wave(y, fam_vars, "FAMILY")
  if (!is.null(out)) attr(out, "map_row") <- row
  out
})
fam <- rbindlist(fam_list, fill = TRUE)
if (!nrow(fam)) stop("Loaded 0 rows for FAMILY; verify psid_dir and your CSV ER codes.")

# ---- build INDIVIDUAL by year (optional, but needed for family-individual panel)
ind_list <- lapply(years, function(y) {
  row <- map[year == y]
  if (!nrow(row)) return(NULL)
  ind_vars <- unlist(row[, ..ind_cols], use.names = FALSE)
  out <- load_wave(y, ind_vars, "IND")
  if (!is.null(out)) attr(out, "map_row") <- row
  out
})
ind <- rbindlist(ind_list, fill = TRUE)  # may be 0-row if you didn't fill IND ERs; that's ok

# rename columns to stable names AFTER selection (preserves ER-based construction)
# Build a per-year rename map so columns line up even if ERs change by wave.
canonical_names <- c(fam_cols, ind_cols)
canonical_names <- unique(canonical_names)

safe_rename_year <- function(DT, row) {
  if (!nrow(DT)) return(DT)
  `%notin%` <- Negate(`%in%`)
  rn <- function(old, new) if (!is.null(old) && length(old) && old %in% names(DT) && new %notin% names(DT)) setnames(DT, old, new)
  # Attempt for all canonical names present in map row
  for (nm in canonical_names) {
    if (nm %in% names(row)) rn(row[[nm]], nm)
  }
  DT
}

# Apply the rename per year to make the stacked tables consistent
fam <- rbindlist(lapply(years, function(y) {
  DT <- fam[year == y]
  if (!nrow(DT)) return(DT)
  safe_rename_year(copy(DT), map[year == y])
}), fill = TRUE)

ind <- rbindlist(lapply(years, function(y) {
  DT <- ind[year == y]
  if (!nrow(DT)) return(DT)
  safe_rename_year(copy(DT), map[year == y])
}), fill = TRUE)

# pick keys
has_famid <- "ER_famid1968"   %in% names(fam)
has_intno <- "ER_interview_num" %in% names(fam)

if (!has_famid && !has_intno) {
  stop("Your FAMILY selection does not include ER_famid1968 nor ER_interview_num. Add at least one to your CSV.")
}

# collapse to one record per (year, family)
if (has_famid) {
  fam[, n_rows := .N, by = .(year, ER_famid1968)]
  fam_year <- fam[, .SD[1], by = .(year, ER_famid1968)]   # choose first if duplicates; adjust rule if needed
  key_cols_fam <- c("year", "ER_famid1968")
} else {
  fam[, n_rows := .N, by = .(year, ER_interview_num)]
  fam_year <- fam[, .SD[1], by = .(year, ER_interview_num)]
  key_cols_fam <- c("year", "ER_interview_num")
}

# family–individual-year (only if you included ER_perid1968 in your CSV)
panel_fi <- NULL
if (nrow(ind) && ("ER_perid1968" %in% names(ind))) {
  # Align keys: prefer famid1968; else fallback to interview number
  key_cols <- if ("ER_famid1968" %in% names(ind) && has_famid) c("year","ER_famid1968") else c("year","ER_interview_num")
  missing_keys <- setdiff(key_cols, names(ind))
  if (length(missing_keys)) {
    warning("IND is missing keys: ", paste(missing_keys, collapse = ", "),
            ". Add their ERs to the CSV if you want the merged panel.")
  } else {
    # Keep one row per (year, family, person) in IND
    setkeyv(ind, c(key_cols, "ER_perid1968"))
    # Bring family fields to each person
    panel_fi <- merge(ind, unique(fam_year[, c(key_cols, setdiff(names(fam_year), c(key_cols, "n_rows"))), with = FALSE]),
                      by = key_cols, all.x = TRUE, suffixes = c("_ind", "_fam"))
  }
}

# outputs
out_dir <- file.path(psid_dir, "_build_out")
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)

fwrite(fam_year, file.path(out_dir, "family_year_by_ER.csv"))
if (!is.null(panel_fi)) fwrite(panel_fi, file.path(out_dir, "family_individual_year_by_ER.csv"))

# quick report
message("\nBuild complete.")
message("Years requested: ", paste(years, collapse = ", "))
message("FAMILY rows: ", nrow(fam_year))
if (!is.null(panel_fi)) message("FAM-IND rows: ", nrow(panel_fi))
message("Output folder: ", out_dir)

```

```

