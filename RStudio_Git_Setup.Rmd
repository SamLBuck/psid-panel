---
title: "Git_Setup"
output: html_document
date: "2025-10-20"
---


```{r 3_without_psidR}

library(tidyverse)
library(readr)
install.packages('arrow')
library(arrow)
install.packages('glue')
library(glue)
install.packages('stringr')
library(stringr)
install.packages('fs')
library(fs)
install.packages('here')
library(here)
```

```{r 4_without_psidR}
DATA_DIR  <- here("data_raw")
XWALK_DIR <- here("xwalk")
OUT_PATH  <- here("output", "psid_family_year_2001_latest.parquet")

# Which waves to try (keep the ones you actually have on disk)
waves <- c(2001,2003)

# 1) Parse dictionaries (.sps or .do) -> (var, start, end, type)

# SPSS DATA LIST fixed-width lines often look like:
#   VAR1  1-3
#   VAR2  4-10 (A)   # A denotes string
# Sometimes they appear as:  VAR1 1-3, VAR2 4-10 (A), ...
parse_sps_positions <- function(dict_path) {
  lines <- read_lines(dict_path)
  # Keep likely spec lines after "DATA LIST" or "/"
  body <- lines[which(str_detect(lines, regex("^DATA LIST", ignore_case = TRUE))):length(lines)]
  body <- body[which(str_detect(body, "^/")):length(body)]
  body <- str_replace_all(body, "\\t", " ")
  body <- str_squish(body)

  # Split on spaces and commas; capture patterns like NAME 1-3 or NAME 1-3 (A)
  specs <- str_extract_all(body, "[A-Za-z0-9_]+\\s+\\d+\\s*-\\s*\\d+(?:\\s*\\([A-Za-z]\\))?")
  specs <- unlist(specs)
  specs <- specs[!is.na(specs) & specs != ""]

  tibble(raw = specs) %>%
    mutate(
      var   = str_match(raw, "^([A-Za-z0-9_]+)\\s+")[,2],
      rng   = str_match(raw, "\\s(\\d+\\s*-\\s*\\d+)")[,2],
      start = as.integer(str_match(rng, "^(\\d+)")[,2]),
      end   = as.integer(str_match(rng, "(\\d+)$")[,1]),
      type  = if_else(str_detect(raw, "\\([aA]\\)"), "character", "numeric"),
      width = end - start + 1L
    ) %>%
    select(var, start, end, width, type) %>%
    distinct(var, .keep_all = TRUE) %>%
    arrange(start)
}

# Stata .do (infix) lines often look like:
#   infix str5  ER30001  1-5  int ER30002  6-9 ...
# or multiple lines with NAME 1-5
parse_do_positions <- function(dict_path) {
  lines <- read_lines(dict_path)
  lines <- str_squish(lines)
  # Grab segments like "str# NAME start-end" or "byte/int/long NAME start-end"
  tokens <- str_extract_all(lines, "(str\\d+|byte|int|long|double)?\\s*([A-Za-z0-9_]+)\\s+(\\d+)\\s*-\\s*(\\d+)")
  tokens <- unlist(tokens)
  if (length(tokens) == 0) return(tibble(var=character(), start=integer(), end=integer(), width=integer(), type=character()))
  mat <- str_match_all(tokens, "(str\\d+|byte|int|long|double)?\\s*([A-Za-z0-9_]+)\\s+(\\d+)\\s*-\\s*(\\d+)")
  out  <- map_dfr(mat, ~tibble(
    type_token = .x[,2],
    var  = .x[,3],
    start = as.integer(.x[,4]),
    end   = as.integer(.x[,5])
  ))
  out %>%
    mutate(
      width = end - start + 1L,
      type  = case_when(
        str_detect(type_token, "^str\\d+$") ~ "character",
        TRUE ~ "numeric"
      )
    ) %>%
    select(var, start, end, width, type) %>%
    distinct(var, .keep_all = TRUE) %>%
    arrange(start)
}

get_dict_positions <- function(stem) {
  # stem like "FAM2017ER" (without extension), looks in DATA_DIR
  sps <- path(DATA_DIR, paste0(stem, ".sps"))
  dof <- path(DATA_DIR, paste0(stem, ".do"))
  if (file_exists(sps)) return(parse_sps_positions(sps))
  if (file_exists(dof)) return(parse_do_positions(dof))
  stop(glue("No .sps or .do dictionary found for {stem} in {DATA_DIR}"))
}


# 2) Fixed-width reader using dictionary

read_fixed_width <- function(stem) {
  # stem: e.g., "FAM2017ER" or "IND2017ER" (without extension)
  txt <- path(DATA_DIR, paste0(stem, ".txt"))
  if (!file_exists(txt)) stop(glue("Missing {basename(txt)}"))
  dict <- get_dict_positions(stem)

  if (nrow(dict) == 0) stop(glue("No positions parsed from dictionary for {stem}"))

  fwf <- fwf_positions(dict$start, dict$end, dict$var)
  # build col_types string for read_fwf()
  col_types <- paste(ifelse(dict$type == "character", "c", "d"), collapse = "")
  # Read, keeping whitespace/blank as NA; trim whitespace for character cols later
  df <- read_fwf(
    file = txt,
    col_positions = fwf,
    col_types = col_types,
    na = c("", " ", ".", "NA")
  )
  # trim character columns
  char_cols <- names(df)[map_lgl(df, is.character)]
  df <- df %>% mutate(across(all_of(char_cols), ~na_if(str_trim(.x), "")))
  df
}

# 3) Crosswalk loader + rename helper

safe_read_xwalk <- function(fname) {
  path <- path(XWALK_DIR, fname)
  if (!file_exists(path)) {
    warning(glue("Crosswalk {fname} not found; treating as empty."))
    return(tibble(wave=integer(), varname=character(), source=character()))
  }
  read_csv(path, show_col_types = FALSE) %>%
    mutate(wave = as.integer(wave))
}

family_xw <- safe_read_xwalk("family_vars_crosswalk.csv")
hs_xw    <- safe_read_xwalk("head_spouse_crosswalk.csv")
phil_xw  <- safe_read_xwalk("philanthropy_crosswalk.csv")
mob_xw   <- safe_read_xwalk("mobility_crosswalk.csv")
state_xw <- safe_read_xwalk("state_crosswalk.csv")
indocc_xw<- safe_read_xwalk("industry_occupation_xwalk.csv")

apply_xwalk <- function(df, xw, yr) {
  if (nrow(xw) == 0) return(tibble())
  xwy <- xw %>% filter(wave == yr)
  if (nrow(xwy) == 0) return(tibble())
  missing <- setdiff(xwy$source, names(df))
  if (length(missing)) {
    warning(glue("Wave {yr}: missing fields: {paste(missing, collapse=', ')}"))
  }
  keep <- intersect(xwy$source, names(df))
  out  <- df %>% select(all_of(keep))
  # rename to harmonized names in same order
  new_names <- xwy %>% filter(source %in% keep) %>%
    arrange(match(source, keep)) %>% pull(varname)
  names(out) <- new_names
  out
}

# 4) Wave readers (Family + Individual/Roster)

load_family_wave <- function(yr) {
  # Prefer FAM####ER.*; adapt here if your family stem differs
  stem <- glue("FAM{yr}ER")
  read_fixed_width(stem) %>% mutate(wave = yr)
}

load_indiv_wave <- function(yr) {
  # Try IND####ER.* then PR####ER.* (some years only have PR)
  stems <- c(glue("IND{yr}ER"), glue("PR{yr}ER"))
  existing <- stems[file_exists(path(DATA_DIR, paste0(stems, ".txt")))]
  if (length(existing) == 0) stop(glue("No individual/roster file found for {yr}"))
  read_fixed_width(existing[[1]]) %>% mutate(wave = yr)
}

# 5) BUILD PER WAVE (set a few IDs; the rest by crosswalk)

# You need to set the **family id** and **interview year** column names present in the Family file.
# Commonly, family id is an ER3xxxx field consistent across files; confirm in your extracts.
FAMILY_ID_COL   <- "ER30002"  # <- EDIT if your family-id differs
INTERVIEW_YR_COL<- "ER30000"  # <- If absent in some waves, we’ll fallback to literal wave year

# For counting children < 18, set the roster/individual file fields:
INDIV_FAMILY_ID <- "ER30002"  # mirror of family id
AGE_COL         <- "AGE"      # <- EDIT to actual ER code or name in IND/PR file
IN_FU_COL       <- "IN_FU"    # <- 1=in FU; otherwise omit. EDIT to your binary flag name/code
REL_TO_HEAD_COL <- "RELHD"    # <- relationship-to-head; supply numeric codes below if numeric

# Relationship codes for “child of head/spouse”:
REL_CHILD_CODES <- c("CHILD","STEPCHILD","ADOPTED","FOSTER")  # If numeric, replace with integers, e.g., c(3, 4, 5, 6)

build_wave <- function(yr) {
  fam <- load_family_wave(yr)
  ind <- load_indiv_wave(yr)

  if (!FAMILY_ID_COL %in% names(fam)) stop(glue("Set FAMILY_ID_COL correctly; not in Family {yr}"))
  fam_keys <- tibble(
    family_id = fam[[FAMILY_ID_COL]],
    interview_year = if (INTERVIEW_YR_COL %in% names(fam)) as.integer(fam[[INTERVIEW_YR_COL]]) else as.integer(yr)
  )

  fam_core <- apply_xwalk(fam, family_xw, yr)
  phil     <- apply_xwalk(fam, phil_xw, yr)
  mob      <- apply_xwalk(fam, mob_xw, yr)
  st       <- apply_xwalk(fam, state_xw, yr)
  indocc   <- apply_xwalk(fam, indocc_xw, yr)
  hs       <- apply_xwalk(fam, hs_xw, yr)

  # ---- Children under 18 in FU
  # Adapt filters if your IN_FU flag & REL codes are numeric.
  if (!all(c(INDIV_FAMILY_ID, AGE_COL) %in% names(ind))) {
    warning(glue("Wave {yr}: missing roster fields for children<18; producing NA"))
    children <- tibble(family_id = fam[[FAMILY_ID_COL]], n_children_u18 = NA_integer_)
  } else {
    df_ind <- ind
    # Normalize relationship filter for character vs numeric
    rel_ok <- rep(TRUE, nrow(df_ind))
    if (REL_TO_HEAD_COL %in% names(df_ind)) {
      if (is.numeric(df_ind[[REL_TO_HEAD_COL]])) {
        rel_ok <- df_ind[[REL_TO_HEAD_COL]] %in% REL_CHILD_CODES  # set numeric codes above if needed
      } else {
        rel_ok <- df_ind[[REL_TO_HEAD_COL]] %in% REL_CHILD_CODES
      }
    }
    in_fu_ok <- rep(TRUE, nrow(df_ind))
    if (IN_FU_COL %in% names(df_ind)) {
      if (is.numeric(df_ind[[IN_FU_COL]])) {
        in_fu_ok <- df_ind[[IN_FU_COL]] == 1
      } else {
        in_fu_ok <- df_ind[[IN_FU_COL]] %in% c("1","Y","YES")
      }
    }

    children <- df_ind %>%
      filter(
        in_fu_ok,
        rel_ok,
        !is.na(.data[[AGE_COL]]),
        suppressWarnings(as.numeric(.data[[AGE_COL]]) < 18)
      ) %>%
      mutate(family_id = .data[[INDIV_FAMILY_ID]]) %>%
      count(family_id, name = "n_children_u18")
  }

  out <- fam_keys %>%
    bind_cols(fam_core) %>%
    left_join(hs,     by = character()) %>%
    left_join(phil,   by = character()) %>%
    left_join(mob,    by = character()) %>%
    left_join(st,     by = character()) %>%
    left_join(indocc, by = character()) %>%
    left_join(children, by = "family_id") %>%
    mutate(n_children_u18 = coalesce(n_children_u18, 0L),
           wave = yr)

  out
}

# 6) Run across waves and write


panel <- map_dfr(
  waves[waves %in% as.integer(str_extract(dir_ls(DATA_DIR, glob = "FAM*ER.txt") %>% path_file(), "\\d{4}"))],
  build_wave
) %>%
  filter(interview_year >= 2001) %>%
  arrange(family_id, interview_year) %>%
  relocate(family_id, interview_year, wave)

dir_create(path_dir(OUT_PATH))
write_parquet(panel, OUT_PATH)
message("Wrote: ", OUT_PATH)


# 7) Optional: emit template crosswalks if missing
emit_template <- function(fname, df_example, vars) {
  path <- path(XWALK_DIR, fname)
  if (file_exists(path)) return(invisible())
  dir_create(XWALK_DIR)
  tibble(
    wave    = integer(),
    varname = character(),
    source  = character()
  ) %>%
    write_csv(path)
  message(glue("Created empty template: {path}. Fill with rows like:")),
  message(glue("wave,varname,source")),
  message(glue("{min(waves)},{vars[1]},{names(df_example)[1]}"))
}

# Example: create shells if needed (using first available family wave to show column names)
try({
  fam_first <- load_family_wave(min(waves))
  emit_template("family_vars_crosswalk.csv", fam_first, c("total_household_earnings"))
  emit_template("head_spouse_crosswalk.csv", fam_first, c("head_age"))
  emit_template("philanthropy_crosswalk.csv", fam_first, c("donated_any"))
  emit_template("mobility_crosswalk.csv", fam_first, c("moved_since_last"))
  emit_template("state_crosswalk.csv", fam_first, c("state_fips"))
  emit_template("industry_occupation_xwalk.csv", fam_first, c("head_industry_code"))
}, silent = TRUE)



```

