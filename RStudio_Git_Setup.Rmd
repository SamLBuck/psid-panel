---
title: "Git_Setup"
output: html_document
date: "2025-10-20"
---

```{r setup, include=FALSE}
setwd('C:/Users/frost01/Documents/PSIDdata')
#install.packages("readxl")
library(readxl)
#install.packages('psidR')
library(psidR)
#install.packages('devtools')
    library(devtools)

#install.packages("data.table")
library(data.table)

install.packages("remotes")   # only if you don’t already have it
remotes::install_github("floswald/psidR")
remove.packages("psidR")

remotes::install_github(
  "floswald/psidR",
  force = TRUE,
  build_vignettes = FALSE,
  dependencies = TRUE
)

```

## R
```{r}
psid_dir <- "C:/Users/frost01/Documents/PSIDdata"
dir.create(psid_dir, showWarnings = FALSE, recursive = TRUE)

# some psidR builds honor this to skip the prompt
options(psidR.auto.download = TRUE)

# try again; include download flag if your version supports it
fam_year <- psidR::build.panel(
  datadir    = psid_dir,
  fam.vars   = fam_vars,
  ind.vars   = NULL,
  heads.only = TRUE,
  design     = "all",
  download   = TRUE   # if your psidR has this arg
)

install.packages("psidR")
library(psidR)
years_needed <- unique(fam_vars$year)

packageVersion("psidR")      # should now show ≥ 2.4


options(
  psidR.icpsr.user = "samuel.buck@hope.edu",   
  psidR.icpsr.pass = "123Turtles123",  # 
  psidR.auto.download = TRUE,
  timeout = max(600, getOption("timeout"))
)

packageVersion("psidR")
ls("package:psidR")               
list.files(psid_dir)    


psid_dir <- normalizePath("C:/Users/frost01/Documents/PSIDdata", winslash="/")
if (!grepl("/$", psid_dir)) psid_dir <- paste0(psid_dir, "/")
dir.create(psid_dir, showWarnings = FALSE, recursive = TRUE)

fam_year <- psidR::build.panel(
  datadir    = psid_dir,
  fam.vars   = fam_vars,
  ind.vars   = NULL,
  heads.only = TRUE,
  design     = "all"
)

list.files("C:/Users/frost01/Documents/PSIDdata", pattern="FAM2017ER")
psid_dir <- "C:/Users/frost01/Documents/PSIDdata/"
psid_dir <- "C:/Users/frost01/Documents/PSIDdata/"

list.files(psid_dir, pattern = "^FAM2017ER\\.(txt|TXT)$")
list.files(psid_dir, pattern = "^FAM2017ER\\.(do|sps|DO|SPS)$")


psidR::build.psid(years = 2017, where = psid_dir)


library(psidR)

psid_dir <- "C:/Users/frost01/Documents/PSIDdata/"
if (!grepl("/$", psid_dir)) psid_dir <- paste0(psid_dir, "/")

# sanity: files must be EXTRACTED in psid_dir with these exact stems
stopifnot(
  file.exists(file.path(psid_dir, "FAM2017ER.txt")),
  file.exists(file.path(psid_dir, "FAM2017ER.do")) || 
  file.exists(file.path(psid_dir, "FAM2017ER.sps"))
)

# CALL POSITIONALLY (no arg names)
psidR::build.psid(2017, psid_dir)

# confirm the R data was created
list.files(psid_dir, pattern = "(?i)^FAM2017ER\\.(rda|rdata)$")

args(psidR::build.psid)
# or, to see the body:
getAnywhere(build.psid)

dat2017 <- psidR:::read.psid(2017, psid_dir, syntax = "do", encoding = "latin1")
save(dat2017, file = file.path(psid_dir, "FAM2017ER.RDA"))


```

```{r cars}




psid_dir <- "C:/Users/frost01/Documents/PSIDdata"       # <-- change if needed
stopifnot(dir.exists(psid_dir))

# 2) load your CSV of ER codes (the one you filled)
map_csv <- "C:/Users/frost01/Documents/PSIDdata/Fill_this_with_ER_variable_numbers_by_wave__save_and_reupload_if_you_edit_locally__.csv"
stopifnot(file.exists(map_csv))
map <- fread(map_csv)

#only odd years
map <- map[year %% 2 == 1]

# 3) construct fam.vars and ind.vars in the format build.panel() expects:
# one row per year
#each column is a variable “name” you want in the output
# each cell is the *ER variable name for that wave
norm_na <- function(x) { x[is.na(x)] <- ""; x }

# choose which columns to pull from FAMILY and IND files
fam_vars <- data.frame(
  year      = map$year,
  interview = norm_na(map$ER_interview_num),        # REQUIRED to join across files reliably
  faminc    = norm_na(map$ER_total_family_income),  # example: total family income
  release   = norm_na(map$ER_release_num),          # optional
  hh_id     = norm_na(map$ER_household_ID),         # optional
  seqnum    = norm_na(map$ER_sequence_num),         # optional
  stringsAsFactors = FALSE
)

# drop columns that are entirely blank
fam_vars <- fam_vars[, colSums(fam_vars != "") > 0, drop = FALSE]

# IND file selections
ind_vars <- data.frame(
  year        = map$year,
  rel_to_head = norm_na(map$ER_relation_to_head),   # relation code
  age         = norm_na(map$ER_age),                # age
  stringsAsFactors = FALSE
)

ind_vars <- ind_vars[, colSums(ind_vars != "") > 0, drop = FALSE]

if (!("year" %in% names(fam_vars)) || ncol(fam_vars) < 2) {
  stop("fam.vars has no usable variables (only 'year'). Fill ER codes in your CSV for at least 'ER_interview_num' and one data field.")
}

# 4) build family–year 
fam_year <- psidR::build.panel(
  datadir     = psid_dir,
  fam.vars    = fam_vars,
  ind.vars    = NULL,          # family-year only
  heads.only  = TRUE,
  design      = "all"          # keep all observed heads across years
)

cat("fam_year dim:", paste(dim(fam_year), collapse = " x "), "\n")
print(head(fam_year))

# 5) optional: build family–individual–year (adds IND vars you specified)
fi_long <- psidR::build.panel(
  datadir     = psid_dir,
  fam.vars    = fam_vars,
  ind.vars    = if (ncol(ind_vars) > 1) ind_vars else NULL,
  heads.only  = FALSE,
  design      = "all"
)

cat("fi_long  dim:", paste(dim(fi_long), collapse = " x "), "\n")
print(head(fi_long))

# 6) write outputs
out_dir <- file.path(psid_dir, "_psidR_outputs")
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)
data.table::fwrite(as.data.table(fam_year), file.path(out_dir, "family_year_psidR.csv"))
data.table::fwrite(as.data.table(fi_long),  file.path(out_dir, "family_individual_year_psidR.csv"))
cat("Wrote:\n  - ", file.path(out_dir, "family_year_psidR.csv"),
    "\n  - ", file.path(out_dir, "family_individual_year_psidR.csv"), "\n")
# ---- paths
psid_dir <- "C:/Users/frost01/Documents/PSIDdata"   # <-- CHANGE THIS to your actual folder
# 2) Your ER crosswalk CSV (the one you filled)
map_csv  <- "C:/Users/frost01/Documents/Fill_this_with_ER_variable_numbers_by_wave__save_and_reupload_if_you_edit_locally__.csv"

# ---- sanity checks
if (!dir.exists(psid_dir)) stop("psid_dir doesn't exist: ", psid_dir)
if (!file.exists(map_csv)) stop("Crosswalk CSV not found: ", map_csv)

# ---- read mapping (must include at least: year, ER_famid1968 or ER_interview_num)
map <- fread(map_csv)
if (!"year" %in% names(map)) stop("Your CSV must have a 'year' column.")

# If you only want odd-year panel, uncomment next line:
# map <- map[year %% 2 == 1]

years <- sort(unique(map$year))

# ---- helper: fuzzy file finder (no fixed folder structure required)
find_file <- function(year, kind = c("FAMILY","IND")) {
  kind <- match.arg(kind)
  if (!dir.exists(psid_dir)) return(NA_character_)
  # Look for family vs individual files; accept both .dta and .sas7bdat
  pat_base <- if (kind == "FAMILY") "(FAM|FAMILY)" else "(IND|INDIV)"
  # prioritize year in filename
  all <- list.files(psid_dir, pattern = "\\.(dta|sas7bdat)$", full.names = TRUE,
                    ignore.case = TRUE, recursive = TRUE)
  cand <- grep(pat_base, all, ignore.case = TRUE, value = TRUE)
  # prefer those that include the 4-digit year
  cand_year <- grep(sprintf("%d", year), cand, value = TRUE)
  pick <- if (length(cand_year)) cand_year else cand
  if (!length(pick)) return(NA_character_)
  pick[1]
}

# ---- loader that selects only the ER codes provided for that year
load_wave <- function(year, er_vars, kind = c("FAMILY","IND")) {
  kind <- match.arg(kind)
  f <- find_file(year, kind)
  if (is.na(f)) {
    warning(sprintf("%s file missing for %s (search under: %s)", kind, year, psid_dir))
    return(NULL)
  }
  dt <- if (grepl("\\.dta$", f, ignore.case = TRUE)) read_dta(f) else read_sas(f)
  setDT(dt)
  # Select strictly by ER names; ignore blanks/missing from the CSV
  keep <- er_vars[er_vars != "" & !is.na(er_vars)]
  keep <- intersect(keep, names(dt))
  if (!length(keep)) {
    warning(sprintf("No requested ER variables found in %s %s (file: %s)", kind, year, basename(f)))
    return(NULL)
  }
  out <- dt[, ..keep]
  out[, year := year]
  attr(out, "source_file") <- f
  out
}

# columns expected in your CSV (names can be different, but these are assumed below)
# FAMILY-level candidates
fam_cols <- c("ER_release_num", "ER_total_family_income", "ER_household_ID",
              "ER_interview_num", "ER_sequence_num", "ER_famid1968")
need_any_fam_key <- c("ER_famid1968", "ER_interview_num")

# INDIVIDUAL-level candidates
ind_cols <- c("ER_relation_to_head", "ER_age", "ER_perid1968", "ER_famid1968", "ER_interview_num")

#build FAMILY by year
fam_list <- lapply(years, function(y) {
  row <- map[year == y]
  if (!nrow(row)) return(NULL)
  fam_vars <- unlist(row[, ..fam_cols], use.names = FALSE)
  out <- load_wave(y, fam_vars, "FAMILY")
  if (!is.null(out)) attr(out, "map_row") <- row
  out
})
fam <- rbindlist(fam_list, fill = TRUE)
if (!nrow(fam)) stop("Loaded 0 rows for FAMILY; verify psid_dir and your CSV ER codes.")

# ---- build INDIVIDUAL by year (optional, but needed for family-individual panel)
ind_list <- lapply(years, function(y) {
  row <- map[year == y]
  if (!nrow(row)) return(NULL)
  ind_vars <- unlist(row[, ..ind_cols], use.names = FALSE)
  out <- load_wave(y, ind_vars, "IND")
  if (!is.null(out)) attr(out, "map_row") <- row
  out
})
ind <- rbindlist(ind_list, fill = TRUE)  # may be 0-row if you didn't fill IND ERs; that's ok

# rename columns to stable names AFTER selection (preserves ER-based construction)
# Build a per-year rename map so columns line up even if ERs change by wave.
canonical_names <- c(fam_cols, ind_cols)
canonical_names <- unique(canonical_names)

safe_rename_year <- function(DT, row) {
  if (!nrow(DT)) return(DT)
  `%notin%` <- Negate(`%in%`)
  rn <- function(old, new) if (!is.null(old) && length(old) && old %in% names(DT) && new %notin% names(DT)) setnames(DT, old, new)
  # Attempt for all canonical names present in map row
  for (nm in canonical_names) {
    if (nm %in% names(row)) rn(row[[nm]], nm)
  }
  DT
}

# Apply the rename per year to make the stacked tables consistent
fam <- rbindlist(lapply(years, function(y) {
  DT <- fam[year == y]
  if (!nrow(DT)) return(DT)
  safe_rename_year(copy(DT), map[year == y])
}), fill = TRUE)

ind <- rbindlist(lapply(years, function(y) {
  DT <- ind[year == y]
  if (!nrow(DT)) return(DT)
  safe_rename_year(copy(DT), map[year == y])
}), fill = TRUE)

# pick keys
has_famid <- "ER_famid1968"   %in% names(fam)
has_intno <- "ER_interview_num" %in% names(fam)

if (!has_famid && !has_intno) {
  stop("Your FAMILY selection does not include ER_famid1968 nor ER_interview_num. Add at least one to your CSV.")
}

# collapse to one record per (year, family)
if (has_famid) {
  fam[, n_rows := .N, by = .(year, ER_famid1968)]
  fam_year <- fam[, .SD[1], by = .(year, ER_famid1968)]   # choose first if duplicates; adjust rule if needed
  key_cols_fam <- c("year", "ER_famid1968")
} else {
  fam[, n_rows := .N, by = .(year, ER_interview_num)]
  fam_year <- fam[, .SD[1], by = .(year, ER_interview_num)]
  key_cols_fam <- c("year", "ER_interview_num")
}

# family–individual-year (only if you included ER_perid1968 in your CSV)
panel_fi <- NULL
if (nrow(ind) && ("ER_perid1968" %in% names(ind))) {
  # Align keys: prefer famid1968; else fallback to interview number
  key_cols <- if ("ER_famid1968" %in% names(ind) && has_famid) c("year","ER_famid1968") else c("year","ER_interview_num")
  missing_keys <- setdiff(key_cols, names(ind))
  if (length(missing_keys)) {
    warning("IND is missing keys: ", paste(missing_keys, collapse = ", "),
            ". Add their ERs to the CSV if you want the merged panel.")
  } else {
    # Keep one row per (year, family, person) in IND
    setkeyv(ind, c(key_cols, "ER_perid1968"))
    # Bring family fields to each person
    panel_fi <- merge(ind, unique(fam_year[, c(key_cols, setdiff(names(fam_year), c(key_cols, "n_rows"))), with = FALSE]),
                      by = key_cols, all.x = TRUE, suffixes = c("_ind", "_fam"))
  }
}

# outputs
out_dir <- file.path(psid_dir, "_build_out")
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)

fwrite(fam_year, file.path(out_dir, "family_year_by_ER.csv"))
if (!is.null(panel_fi)) fwrite(panel_fi, file.path(out_dir, "family_individual_year_by_ER.csv"))

# quick report
message("\nBuild complete.")
message("Years requested: ", paste(years, collapse = ", "))
message("FAMILY rows: ", nrow(fam_year))
if (!is.null(panel_fi)) message("FAM-IND rows: ", nrow(panel_fi))
message("Output folder: ", out_dir)

```

```{r 3_without_psidR}

install.packages("tidyverse")
intall.packages("readr")
library(tidyverse)
library(readr)
library(arrow)
library(glue)
library(stringr)
library(fs)
library(here)

DATA_DIR  <- here("data_raw")
XWALK_DIR <- here("xwalk")
OUT_PATH  <- here("output", "psid_family_year_2001_latest.parquet")

# Which waves to try (keep the ones you actually have on disk)
waves <- c(2001,2003,2005,2007,2009,2011,2013,2015,2017,2019,2021,2023)

# 1) Parse dictionaries (.sps or .do) -> (var, start, end, type)

# SPSS DATA LIST fixed-width lines often look like:
#   VAR1  1-3
#   VAR2  4-10 (A)   # A denotes string
# Sometimes they appear as:  VAR1 1-3, VAR2 4-10 (A), ...
parse_sps_positions <- function(dict_path) {
  lines <- read_lines(dict_path)
  # Keep likely spec lines after "DATA LIST" or "/"
  body <- lines[which(str_detect(lines, regex("^DATA LIST", ignore_case = TRUE))):length(lines)]
  body <- body[which(str_detect(body, "^/")):length(body)]
  body <- str_replace_all(body, "\\t", " ")
  body <- str_squish(body)

  # Split on spaces and commas; capture patterns like NAME 1-3 or NAME 1-3 (A)
  specs <- str_extract_all(body, "[A-Za-z0-9_]+\\s+\\d+\\s*-\\s*\\d+(?:\\s*\\([A-Za-z]\\))?")
  specs <- unlist(specs)
  specs <- specs[!is.na(specs) & specs != ""]

  tibble(raw = specs) %>%
    mutate(
      var   = str_match(raw, "^([A-Za-z0-9_]+)\\s+")[,2],
      rng   = str_match(raw, "\\s(\\d+\\s*-\\s*\\d+)")[,2],
      start = as.integer(str_match(rng, "^(\\d+)")[,2]),
      end   = as.integer(str_match(rng, "(\\d+)$")[,1]),
      type  = if_else(str_detect(raw, "\\([aA]\\)"), "character", "numeric"),
      width = end - start + 1L
    ) %>%
    select(var, start, end, width, type) %>%
    distinct(var, .keep_all = TRUE) %>%
    arrange(start)
}

# Stata .do (infix) lines often look like:
#   infix str5  ER30001  1-5  int ER30002  6-9 ...
# or multiple lines with NAME 1-5
parse_do_positions <- function(dict_path) {
  lines <- read_lines(dict_path)
  lines <- str_squish(lines)
  # Grab segments like "str# NAME start-end" or "byte/int/long NAME start-end"
  tokens <- str_extract_all(lines, "(str\\d+|byte|int|long|double)?\\s*([A-Za-z0-9_]+)\\s+(\\d+)\\s*-\\s*(\\d+)")
  tokens <- unlist(tokens)
  if (length(tokens) == 0) return(tibble(var=character(), start=integer(), end=integer(), width=integer(), type=character()))
  mat <- str_match_all(tokens, "(str\\d+|byte|int|long|double)?\\s*([A-Za-z0-9_]+)\\s+(\\d+)\\s*-\\s*(\\d+)")
  out  <- map_dfr(mat, ~tibble(
    type_token = .x[,2],
    var  = .x[,3],
    start = as.integer(.x[,4]),
    end   = as.integer(.x[,5])
  ))
  out %>%
    mutate(
      width = end - start + 1L,
      type  = case_when(
        str_detect(type_token, "^str\\d+$") ~ "character",
        TRUE ~ "numeric"
      )
    ) %>%
    select(var, start, end, width, type) %>%
    distinct(var, .keep_all = TRUE) %>%
    arrange(start)
}

get_dict_positions <- function(stem) {
  # stem like "FAM2017ER" (without extension), looks in DATA_DIR
  sps <- path(DATA_DIR, paste0(stem, ".sps"))
  dof <- path(DATA_DIR, paste0(stem, ".do"))
  if (file_exists(sps)) return(parse_sps_positions(sps))
  if (file_exists(dof)) return(parse_do_positions(dof))
  stop(glue("No .sps or .do dictionary found for {stem} in {DATA_DIR}"))
}


# 2) Fixed-width reader using dictionary

read_fixed_width <- function(stem) {
  # stem: e.g., "FAM2017ER" or "IND2017ER" (without extension)
  txt <- path(DATA_DIR, paste0(stem, ".txt"))
  if (!file_exists(txt)) stop(glue("Missing {basename(txt)}"))
  dict <- get_dict_positions(stem)

  if (nrow(dict) == 0) stop(glue("No positions parsed from dictionary for {stem}"))

  fwf <- fwf_positions(dict$start, dict$end, dict$var)
  # build col_types string for read_fwf()
  col_types <- paste(ifelse(dict$type == "character", "c", "d"), collapse = "")
  # Read, keeping whitespace/blank as NA; trim whitespace for character cols later
  df <- read_fwf(
    file = txt,
    col_positions = fwf,
    col_types = col_types,
    na = c("", " ", ".", "NA")
  )
  # trim character columns
  char_cols <- names(df)[map_lgl(df, is.character)]
  df <- df %>% mutate(across(all_of(char_cols), ~na_if(str_trim(.x), "")))
  df
}

# 3) Crosswalk loader + rename helper

safe_read_xwalk <- function(fname) {
  path <- path(XWALK_DIR, fname)
  if (!file_exists(path)) {
    warning(glue("Crosswalk {fname} not found; treating as empty."))
    return(tibble(wave=integer(), varname=character(), source=character()))
  }
  read_csv(path, show_col_types = FALSE) %>%
    mutate(wave = as.integer(wave))
}

family_xw <- safe_read_xwalk("family_vars_crosswalk.csv")
hs_xw    <- safe_read_xwalk("head_spouse_crosswalk.csv")
phil_xw  <- safe_read_xwalk("philanthropy_crosswalk.csv")
mob_xw   <- safe_read_xwalk("mobility_crosswalk.csv")
state_xw <- safe_read_xwalk("state_crosswalk.csv")
indocc_xw<- safe_read_xwalk("industry_occupation_xwalk.csv")

apply_xwalk <- function(df, xw, yr) {
  if (nrow(xw) == 0) return(tibble())
  xwy <- xw %>% filter(wave == yr)
  if (nrow(xwy) == 0) return(tibble())
  missing <- setdiff(xwy$source, names(df))
  if (length(missing)) {
    warning(glue("Wave {yr}: missing fields: {paste(missing, collapse=', ')}"))
  }
  keep <- intersect(xwy$source, names(df))
  out  <- df %>% select(all_of(keep))
  # rename to harmonized names in same order
  new_names <- xwy %>% filter(source %in% keep) %>%
    arrange(match(source, keep)) %>% pull(varname)
  names(out) <- new_names
  out
}

# 4) Wave readers (Family + Individual/Roster)

load_family_wave <- function(yr) {
  # Prefer FAM####ER.*; adapt here if your family stem differs
  stem <- glue("FAM{yr}ER")
  read_fixed_width(stem) %>% mutate(wave = yr)
}

load_indiv_wave <- function(yr) {
  # Try IND####ER.* then PR####ER.* (some years only have PR)
  stems <- c(glue("IND{yr}ER"), glue("PR{yr}ER"))
  existing <- stems[file_exists(path(DATA_DIR, paste0(stems, ".txt")))]
  if (length(existing) == 0) stop(glue("No individual/roster file found for {yr}"))
  read_fixed_width(existing[[1]]) %>% mutate(wave = yr)
}

# 5) BUILD PER WAVE (set a few IDs; the rest by crosswalk)

# You need to set the **family id** and **interview year** column names present in the Family file.
# Commonly, family id is an ER3xxxx field consistent across files; confirm in your extracts.
FAMILY_ID_COL   <- "ER30002"  # <- EDIT if your family-id differs
INTERVIEW_YR_COL<- "ER30000"  # <- If absent in some waves, we’ll fallback to literal wave year

# For counting children < 18, set the roster/individual file fields:
INDIV_FAMILY_ID <- "ER30002"  # mirror of family id
AGE_COL         <- "AGE"      # <- EDIT to actual ER code or name in IND/PR file
IN_FU_COL       <- "IN_FU"    # <- 1=in FU; otherwise omit. EDIT to your binary flag name/code
REL_TO_HEAD_COL <- "RELHD"    # <- relationship-to-head; supply numeric codes below if numeric

# Relationship codes for “child of head/spouse”:
REL_CHILD_CODES <- c("CHILD","STEPCHILD","ADOPTED","FOSTER")  # If numeric, replace with integers, e.g., c(3, 4, 5, 6)

build_wave <- function(yr) {
  fam <- load_family_wave(yr)
  ind <- load_indiv_wave(yr)

  if (!FAMILY_ID_COL %in% names(fam)) stop(glue("Set FAMILY_ID_COL correctly; not in Family {yr}"))
  fam_keys <- tibble(
    family_id = fam[[FAMILY_ID_COL]],
    interview_year = if (INTERVIEW_YR_COL %in% names(fam)) as.integer(fam[[INTERVIEW_YR_COL]]) else as.integer(yr)
  )

  fam_core <- apply_xwalk(fam, family_xw, yr)
  phil     <- apply_xwalk(fam, phil_xw, yr)
  mob      <- apply_xwalk(fam, mob_xw, yr)
  st       <- apply_xwalk(fam, state_xw, yr)
  indocc   <- apply_xwalk(fam, indocc_xw, yr)
  hs       <- apply_xwalk(fam, hs_xw, yr)

  # ---- Children under 18 in FU
  # Adapt filters if your IN_FU flag & REL codes are numeric.
  if (!all(c(INDIV_FAMILY_ID, AGE_COL) %in% names(ind))) {
    warning(glue("Wave {yr}: missing roster fields for children<18; producing NA"))
    children <- tibble(family_id = fam[[FAMILY_ID_COL]], n_children_u18 = NA_integer_)
  } else {
    df_ind <- ind
    # Normalize relationship filter for character vs numeric
    rel_ok <- rep(TRUE, nrow(df_ind))
    if (REL_TO_HEAD_COL %in% names(df_ind)) {
      if (is.numeric(df_ind[[REL_TO_HEAD_COL]])) {
        rel_ok <- df_ind[[REL_TO_HEAD_COL]] %in% REL_CHILD_CODES  # set numeric codes above if needed
      } else {
        rel_ok <- df_ind[[REL_TO_HEAD_COL]] %in% REL_CHILD_CODES
      }
    }
    in_fu_ok <- rep(TRUE, nrow(df_ind))
    if (IN_FU_COL %in% names(df_ind)) {
      if (is.numeric(df_ind[[IN_FU_COL]])) {
        in_fu_ok <- df_ind[[IN_FU_COL]] == 1
      } else {
        in_fu_ok <- df_ind[[IN_FU_COL]] %in% c("1","Y","YES")
      }
    }

    children <- df_ind %>%
      filter(
        in_fu_ok,
        rel_ok,
        !is.na(.data[[AGE_COL]]),
        suppressWarnings(as.numeric(.data[[AGE_COL]]) < 18)
      ) %>%
      mutate(family_id = .data[[INDIV_FAMILY_ID]]) %>%
      count(family_id, name = "n_children_u18")
  }

  out <- fam_keys %>%
    bind_cols(fam_core) %>%
    left_join(hs,     by = character()) %>%
    left_join(phil,   by = character()) %>%
    left_join(mob,    by = character()) %>%
    left_join(st,     by = character()) %>%
    left_join(indocc, by = character()) %>%
    left_join(children, by = "family_id") %>%
    mutate(n_children_u18 = coalesce(n_children_u18, 0L),
           wave = yr)

  out
}

# 6) Run across waves and write


panel <- map_dfr(
  waves[waves %in% as.integer(str_extract(dir_ls(DATA_DIR, glob = "FAM*ER.txt") %>% path_file(), "\\d{4}"))],
  build_wave
) %>%
  filter(interview_year >= 2001) %>%
  arrange(family_id, interview_year) %>%
  relocate(family_id, interview_year, wave)

dir_create(path_dir(OUT_PATH))
write_parquet(panel, OUT_PATH)
message("Wrote: ", OUT_PATH)


# 7) Optional: emit template crosswalks if missing
emit_template <- function(fname, df_example, vars) {
  path <- path(XWALK_DIR, fname)
  if (file_exists(path)) return(invisible())
  dir_create(XWALK_DIR)
  tibble(
    wave    = integer(),
    varname = character(),
    source  = character()
  ) %>%
    write_csv(path)
  message(glue("Created empty template: {path}. Fill with rows like:")),
  message(glue("wave,varname,source")),
  message(glue("{min(waves)},{vars[1]},{names(df_example)[1]}"))
}

# Example: create shells if needed (using first available family wave to show column names)
try({
  fam_first <- load_family_wave(min(waves))
  emit_template("family_vars_crosswalk.csv", fam_first, c("total_household_earnings"))
  emit_template("head_spouse_crosswalk.csv", fam_first, c("head_age"))
  emit_template("philanthropy_crosswalk.csv", fam_first, c("donated_any"))
  emit_template("mobility_crosswalk.csv", fam_first, c("moved_since_last"))
  emit_template("state_crosswalk.csv", fam_first, c("state_fips"))
  emit_template("industry_occupation_xwalk.csv", fam_first, c("head_industry_code"))
}, silent = TRUE)



```

